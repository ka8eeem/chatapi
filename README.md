# Application Logic

Itâ€™s required to build a chat system. The system should allow creating new applications where each application will have a token(generated by the system) and a name(provided by the client). The token is the identifier that devices use to send chats to that application.

Each application can have many chats. a chat should have a number. Numbering of chats in each application starts from 1 and no 2 chats in the same application may have the same number. The number of the chat should be returned in the chat creation request. 

A chat contains messages and messages have numbers that start from 1 for each chat. The number of the message should also be returned in the message creation request. The client should never see the ID of any of the entities. The client identifies the application by its token and the chat by its number along with the application token.

# Requirements

* Building the API. No GUI is required.
* Using Ruby on Rails(V5) for building the API and the workers.
* Using mysql as our main datastore
* Using rabbitmq as queuing system to avoid race condition
* Using elasticsearch to search the messages body
* Using `docker-compose up` to wrap and run the whole stack

# Approach

as its my first time using RoR i started with a quick [crash course](https://app.pluralsight.com/library/courses/ruby-rails-big-picture)

1) initialized the application boilerplate using `rails new chatApp --api -d mysql`
2) generate migration and models using `rails generate model Application`

one of the biggest challenges was wrapping the stack logic together and make use of rabbitmq, redis and elastic search and connect it to the application request lifecycle

1) the application will receive request through a route
2) the controller will validate the params
3) controller will pass the validated params to rabbitmq publisher
4) rabbitmq consumer will listen to the channel and will do the creation in the database
5) as we need to make use of autoincrement for chat_number per application and message_number per chat, redis hint was enlightening
6) we will use redios `INCR` famous function to store and increment the keys of chat_number per application and message_number per chat
7) i used routing convinent alittle different than the one descriped in the challenge ex: using ?app_token={token}&chat_number={number} as i found it more decoupled and easier to scale than the nested routes of /application/{token}/chat/{number}
8) finally docker compose file was a mess configuring all the netowrk of the different services together xD

## Routes schema

#### New Application

```sh
$ curl -X POST \
    http://localhost:3000/api/v1/applications \
    -H 'cache-control: no-cache' \
    -H 'content-type: application/json' \
    -d '{
  	"name":"app1",
  }'
```

### New Chat

```sh
$ curl -X POST \
    http://localhost:3000/api/v1/chats \
    -H 'cache-control: no-cache' \
    -H 'content-type: application/json' \
    -d '{
  	"app_token":"{app1_token}",
    "chat_users":"Kareem, Ahmed" {descriptive field}
  }'
```

### New Message

```sh
$ curl -X POST \
    http://localhost:3000/api/v1/messages \
    -H 'cache-control: no-cache' \
    -H 'content-type: application/json' \
    -d '{
  	"app_token":"{app1_token}",
    "chat_number":"{chat_number}",
    "message_body":"test message"
  }'
```

### Search Elastic

```sh
$ curl -X POST \
    http://localhost:9200/chat_app/_search \
    -H 'cache-control: no-cache' \
    -H 'content-type: application/json' \
    -d '{                  
      "query": {
          "match": {
              "messages": "get message partially or fully"
          }
      }
  }'
```
